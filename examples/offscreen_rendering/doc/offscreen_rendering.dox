/*
  This file is part of KDGpu.

  SPDX-FileCopyrightText: 2023 Klar√§lvdalens Datakonsult AB, a KDAB Group company <info@kdab.com>

  SPDX-License-Identifier: MIT

  Contact KDAB at <info@kdab.com> for commercial licensing options.
*/

/**
    @page offscreen_rendering Offscreen Rendering
    @ingroup kdgpu-examples

    @brief This example shows how to render to an image file.

    This example demonstrates how to use vulkan to render to an image file instead of presenting to the screen. We have no need for KDGui::GuiApplication or the KDGpu::KDGpuExample helper API, since we don't have an event loop.

    When starting the program, the first thing we do is fill a large vector with vertex information, which represent points we want to plot. These are generated by a function that we won't cover here. Vertices look like this:

    @snippet offscreen_rendering/offscreen.h 1

    We then construct the "Offscreen" object and call its ``initializeScene`` method.

    \section offscreen_createrendertargets createRenderTargets

    The first part of initialization is the constructor, which creates a vulkan API instance, finds a physical adapter, and creates a device and a queue from it:

    @snippet offscreen_rendering/offscreen.cpp 7

    The constructor also calls ``createRenderTargets``, which is a long function that configures and creates all the textures we need, as well as an array of KDGpu::TextureMemoryBarrierOptions, the purpose of which will be shown later. First, let's look at the color texture initialization.

    @snippet offscreen_rendering/offscreen.cpp 8

    We need to create two textures since we are using multisampling. The first texture can be upsampled and then rendered into the second to create the MSAA effect. To use this we simply configure the main pass to use both views:

    @snippet offscreen_rendering/offscreen.cpp 9

    <blockquote>
        For more information on multi-sampling with KDGpu, check out [Hello Triangle MSAA](#hello_triangle_msaa).
    </blockquote>

    Next, we initialize a texture which exists in CPU address space, which we will use as a proxy to render to from vulkan and then copy onto disk in an image format.

    @snippet offscreen_rendering/offscreen.cpp 10

    The ``tiling`` field determines the layout of the texels in memory. ``Optimal`` is the default value, and in that case the texture will be laid out in a more optimized way for whatever hardware the program is running on. ``Linear`` means row-major order, which is best if the texture needs to be CPU-addressable.

    After creating textures, we need to create an array of memory barrier options. First, lets look at how these options are used later, during rendering:

    @snippet offscreen_rendering/offscreen.cpp 11

    Memory barriers are commands which will act to ensure that memory in the CPU cache is flushed and visible to other cores before continuing processing. They also can make changes to the format of memory, which is part of the options we will configure. Before we can perform the ``copyTextureToTexture`` operation, we need to ensure that the texture memory is up-to-date, visible, and in the correct format. Afterwards, we need memory barriers to reset the GPU texture to its original format and to set up the CPU texture's format so it can be mapped to CPU address space. So, lets set the different memory barrier options:

    @snippet offscreen_rendering/offscreen.cpp 12

    The last step is to create the copy options for the ``copyTextureToTexture`` call shown earlier:

    @snippet offscreen_rendering/offscreen.cpp 13

    \section offscreen_initialization initializeScene

    The first thing to do on scene initialization is to load the image that we use represent points on the graph. The majority of this is identical to the texture loading seen in the [Textured Quad](textured_quad) example, including the same ``loadImage`` helper function. One difference is that we set the scaling filters for upscaling and downscaling.

    @snippet offscreen_rendering/offscreen.cpp 1

    Also, we keep track of the buffer upload information in a member variable, to free later. This is a housekeeping task which normally would handled by KDGpuExample::ExampleEngineLayer::uploadBufferData.

    @snippet offscreen_rendering/offscreen.cpp 7

    Next we load the shaders.

    <blockquote>
        TODO: document gl_PointSize
    </blockquote>

    @snippet offscreen_rendering/doc/shadersnippet.vert 2

    Next, we create a buffer to hold the transformation matrix, called ``m_proj``, and copy an orthographic projection into it:

    @snippet offscreen_rendering/offscreen.cpp 4

    We create the necessary bind group and bind group layouts, and then finally create the pipeline options:

    @snippet offscreen_rendering/offscreen.cpp 5

    Notice:
        - the use of multisampling
        - ``CompareOperation::Always``
        - The pointlist topology, so that the vertices get interpreted as points and not triangles
        - That blending is enabled, with settings for both color and alpha
        - The binding for the vertex buffer that uses the size of the Offscreen::Vertex shown earlier.

    \section offscreen_set_data Data Upload

    Having completed initialization, we need to pass the large vector of vertex data we generated earlier into our Offscreen object. We pass it in with ``setData``:

    @snippet offscreen_rendering/offscreen.cpp 6

    At the end of this function we also keep track of the buffer for release later.

*/
